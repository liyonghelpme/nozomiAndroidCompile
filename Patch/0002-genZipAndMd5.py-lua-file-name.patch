From 1b3afb65d0dd1c04d259646fe26a632f0f321ec3 Mon Sep 17 00:00:00 2001
From: liyonghelpme <liyonghelpme@gmail.com>
Date: Sat, 4 May 2013 13:25:47 +0800
Subject: [PATCH 2/4] =?UTF-8?q?genZipAndMd5.py=20=20=E5=8E=8B=E7=BC=A9=E4?=
 =?UTF-8?q?=BA=86=E6=89=80=E6=9C=89=E7=9A=84=E4=BB=B6=E5=A4=B9=E5=90=8D=E7?=
 =?UTF-8?q?=A7=B0=20=E5=92=8C=20lua=20file=20name=20AssetsManager=20=20=20?=
 =?UTF-8?q?=20windows=20=E5=B9=B3=E5=8F=B0=E4=B8=8B=E9=9D=A2=E9=9C=80=E8?=
 =?UTF-8?q?=A6=81=E5=B0=86=E5=8E=8B=E7=BC=A9file=20=E6=89=80=E6=9C=89=E7?=
 =?UTF-8?q?=9A=84=20=E8=B7=AF=E5=BE=84=E5=90=8D=E7=A7=B0=20=E5=8F=98=E6=88?=
 =?UTF-8?q?=90=20\\?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 nozomi/Classes/AppDelegate.cpp                 |   2 +-
 nozomi/Classes/AssetsManager/AssetsManager.cpp | 462 +++++++++++++++++++++++++
 nozomi/Classes/AssetsManager/AssetsManager.h   | 138 ++++++++
 nozomi/Resources/genZipAndMd5.py               |   1 +
 4 files changed, 602 insertions(+), 1 deletion(-)
 create mode 100644 nozomi/Classes/AssetsManager/AssetsManager.cpp
 create mode 100644 nozomi/Classes/AssetsManager/AssetsManager.h

diff --git a/nozomi/Classes/AppDelegate.cpp b/nozomi/Classes/AppDelegate.cpp
index 77954e8..5c60fec 100644
--- a/nozomi/Classes/AppDelegate.cpp
+++ b/nozomi/Classes/AppDelegate.cpp
@@ -128,7 +128,7 @@ void AppDelegate::loadScript() {
     CCScriptEngineManager::sharedManager()->setScriptEngine(pEngine);
 
     pEngine->addSearchPath(pathToSave.c_str());
-    string runLua = pathToSave+"test2.lua";
+    string runLua = pathToSave+"main.lua";
     cout << "run lua file " << runLua << endl;
     pEngine->executeScriptFile(runLua.c_str());
 }
\ No newline at end of file
diff --git a/nozomi/Classes/AssetsManager/AssetsManager.cpp b/nozomi/Classes/AssetsManager/AssetsManager.cpp
new file mode 100644
index 0000000..c607f43
--- /dev/null
+++ b/nozomi/Classes/AssetsManager/AssetsManager.cpp
@@ -0,0 +1,462 @@
+/****************************************************************************
+ Copyright (c) 2013 cocos2d-x.org
+ 
+ http://www.cocos2d-x.org
+ 
+ Permission is hereby granted, free of charge, to any person obtaining a copy
+ of this software and associated documentation files (the "Software"), to deal
+ in the Software without restriction, including without limitation the rights
+ to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ copies of the Software, and to permit persons to whom the Software is
+ furnished to do so, subject to the following conditions:
+ 
+ The above copyright notice and this permission notice shall be included in
+ all copies or substantial portions of the Software.
+ 
+ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ THE SOFTWARE.
+ ****************************************************************************/
+
+
+#if (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32)
+#define PATHSEP "\\"
+#else
+#define PATHSEP "/"
+#endif
+
+#include "AssetsManager.h"
+#include "cocos2d.h"
+
+#include <curl/curl.h>
+#include <curl/easy.h>
+#include <stdio.h>
+#include <vector>
+
+#if (CC_TARGET_PLATFORM != CC_PLATFORM_WIN32)
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <errno.h>
+#endif
+
+#include "support/zip_support/unzip.h"
+
+using namespace cocos2d;
+using namespace std;
+
+//NS_CC_EXT_BEGIN;
+
+#define KEY_OF_VERSION   "current-version-code"
+#define KEY_OF_DOWNLOADED_VERSION    "downloaded-version-code"
+#define TEMP_PACKAGE_FILE_NAME    "cocos2dx-update-temp-package.zip"
+#define BUFFER_SIZE    8192
+#define MAX_FILENAME   512
+
+AssetsManager::AssetsManager()
+: _packageUrl("")
+, _versionFileUrl("")
+, _version("")
+, _curl(NULL)
+{
+    _storagePath = CCFileUtils::sharedFileUtils()->getWriteablePath();
+    checkStoragePath();
+}
+
+AssetsManager::AssetsManager(const char* packageUrl, const char* versionFileUrl)
+: _packageUrl(packageUrl)
+, _version("")
+, _versionFileUrl(versionFileUrl)
+, _curl(NULL)
+{
+    _storagePath = CCFileUtils::sharedFileUtils()->getWriteablePath();
+    checkStoragePath();
+}
+
+AssetsManager::AssetsManager(const char* packageUrl, const char* versionFileUrl, const char* storagePath)
+: _packageUrl(packageUrl)
+, _version("")
+, _versionFileUrl(versionFileUrl)
+, _storagePath(storagePath)
+, _curl(NULL)
+{
+    checkStoragePath();
+}
+
+void AssetsManager::checkStoragePath()
+{
+       
+#if (CC_TARGET_PLATFORM != CC_PLATFORM_WIN32)
+    if (_storagePath.size() > 0 && _storagePath[_storagePath.size() - 1] != '/')
+    {
+        _storagePath.append("/");
+    }
+#else
+
+#endif
+}
+
+static size_t getVersionCode(void *ptr, size_t size, size_t nmemb, void *userdata)
+{
+    string *version = (string*)userdata;
+    version->append((char*)ptr, size * nmemb);
+    
+    return (size * nmemb);
+}
+
+bool AssetsManager::checkUpdate()
+{
+    if (_versionFileUrl.size() == 0) return false;
+    
+    _curl = curl_easy_init();
+    if (! _curl)
+    {
+        CCLOG("can not init curl");
+        return false;
+    }
+    
+    // Clear _version before assign new value.
+    _version.clear();
+    
+    CURLcode res;
+    curl_easy_setopt(_curl, CURLOPT_URL, _versionFileUrl.c_str());
+    curl_easy_setopt(_curl, CURLOPT_SSL_VERIFYPEER, 0L);
+    curl_easy_setopt(_curl, CURLOPT_WRITEFUNCTION, getVersionCode);
+    curl_easy_setopt(_curl, CURLOPT_WRITEDATA, &_version);
+    res = curl_easy_perform(_curl);
+    
+    if (res != 0)
+    {
+        CCLOG("can not get version file content, error code is %d", res);
+        curl_easy_cleanup(_curl);
+        return false;
+    }
+    
+    string recordedVersion = CCUserDefault::sharedUserDefault()->getStringForKey(KEY_OF_VERSION);
+    if (recordedVersion == _version)
+    {
+        CCLOG("there is not new version");
+        // Set resource search path.
+        setSearchPath();
+        return false;
+    }
+    
+    CCLOG("there is a new version: %s", _version.c_str());
+    
+    return true;
+}
+
+bool AssetsManager::update()
+{
+    // 1. Urls of package and version should be valid;
+    // 2. Package should be a zip file.
+    if (_versionFileUrl.size() == 0 ||
+        _packageUrl.size() == 0 ||
+        std::string::npos == _packageUrl.find(".zip"))
+    {
+        CCLOG("no version file url, or no package url, or the package is not a zip file");
+        return false;
+    }
+    
+    // Check if there is a new version.
+    if (! checkUpdate()) return false;
+    
+    // Is package already downloaded?
+    string downloadedVersion = CCUserDefault::sharedUserDefault()->getStringForKey(KEY_OF_DOWNLOADED_VERSION);
+    if (downloadedVersion != _version)
+    {
+        if (! downLoad()) return false;
+        
+        // Record downloaded version.
+        CCUserDefault::sharedUserDefault()->setStringForKey(KEY_OF_DOWNLOADED_VERSION, _version.c_str());
+        CCUserDefault::sharedUserDefault()->flush();
+    }
+    
+    // Uncompress zip file.
+    if (! uncompress()) return false;
+    
+    // Record new version code.
+    CCUserDefault::sharedUserDefault()->setStringForKey(KEY_OF_VERSION, _version.c_str());
+    
+    // Unrecord downloaded version code.
+    CCUserDefault::sharedUserDefault()->setStringForKey(KEY_OF_DOWNLOADED_VERSION, "");
+    
+    CCUserDefault::sharedUserDefault()->flush();
+    
+    // Set resource search path.
+    setSearchPath();
+    
+    // Delete unloaded zip file.
+    string zipfileName = _storagePath + TEMP_PACKAGE_FILE_NAME;
+    if (remove(zipfileName.c_str()) != 0)
+    {
+        CCLOG("can not remove downloaded zip file");
+    }
+    return true;
+}
+
+bool AssetsManager::uncompress()
+{
+    // Open the zip file
+    string outFileName = _storagePath + TEMP_PACKAGE_FILE_NAME;
+    CCLOG("outFileName %s %s", _storagePath, TEMP_PACKAGE_FILE_NAME);
+    unzFile zipfile = unzOpen(outFileName.c_str());
+
+    if (! zipfile)
+    {
+        CCLOG("can not open downloaded zip file %s", outFileName.c_str());
+        return false;
+    }
+    
+    // Get info about the zip file
+    unz_global_info global_info;
+    if (unzGetGlobalInfo(zipfile, &global_info) != UNZ_OK)
+    {
+        CCLOG("can not read file global info of %s", outFileName.c_str());
+        unzClose(zipfile);
+    }
+    
+    // Buffer to hold data read from the zip file
+    char readBuffer[BUFFER_SIZE];
+    
+    CCLOG("start uncompressing");
+    
+    // Loop to extract all files.
+    uLong i;
+    for (i = 0; i < global_info.number_entry; ++i)
+    {
+        // Get info about current file.
+        unz_file_info fileInfo;
+        char fileName[MAX_FILENAME];
+        if (unzGetCurrentFileInfo(zipfile,
+                                  &fileInfo,
+                                  fileName,
+                                  MAX_FILENAME,
+                                  NULL,
+                                  0,
+                                  NULL,
+                                  0) != UNZ_OK)
+        {
+            CCLOG("can not read file info");
+            unzClose(zipfile);
+            return false;
+        }
+        
+        string fullPath = _storagePath + fileName;
+
+        //windows下替换所有/ 为\\ 路径
+        #if (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32)
+        int position = fullPath.find("/");
+        while(position != std::string::npos) {
+            fullPath.replace(position, 1, "\\");
+            position = fullPath.find("\\", position+1);
+        }
+        #endif   
+
+        //cout << "uncompress full path " << fullPath << endl;
+        
+        // Check if this entry is a directory or a file.
+        const size_t filenameLength = strlen(fileName);
+        if (fileName[filenameLength-1] == '/')
+        {
+            // Entry is a direcotry, so create it.
+            // If the directory exists, it will failed scilently.
+            if (!createDirectory(fullPath.c_str()))
+            {
+                CCLOG("can not create directory %s", fullPath.c_str());
+                unzClose(zipfile);
+                return false;
+            }
+        }
+        else
+        {
+            // Entry is a file, so extract it.
+            
+            // Open current file.
+            if (unzOpenCurrentFile(zipfile) != UNZ_OK)
+            {
+                CCLOG("can not open file %s", fileName);
+                unzClose(zipfile);
+                return false;
+            }
+            
+            // Create a file to store current file.
+            FILE *out = fopen(fullPath.c_str(), "wb");
+            if (! out)
+            {
+                CCLOG("can not open destination file %s", fullPath.c_str());
+                unzCloseCurrentFile(zipfile);
+                unzClose(zipfile);
+                return false;
+            }
+            
+            // Write current file content to destinate file.
+            int error = UNZ_OK;
+            do
+            {
+                error = unzReadCurrentFile(zipfile, readBuffer, BUFFER_SIZE);
+                if (error < 0)
+                {
+                    CCLOG("can not read zip file %s, error code is %d", fileName, error);
+                    unzCloseCurrentFile(zipfile);
+                    unzClose(zipfile);
+                    return false;
+                }
+                
+                if (error > 0)
+                {
+                    fwrite(readBuffer, error, 1, out);
+                }
+            } while(error > 0);
+            
+            fclose(out);
+        }
+        
+        unzCloseCurrentFile(zipfile);
+        
+        // Goto next entry listed in the zip file.
+        if ((i+1) < global_info.number_entry)
+        {
+            //unzGotoNextFile(zipfile);
+            if (unzGoToNextFile(zipfile) != UNZ_OK)
+            {
+                CCLOG("can not read next file");
+                unzClose(zipfile);
+                return false;
+            }
+        }
+    }
+    
+    CCLOG("end uncompressing");
+    
+    return true;
+}
+
+/*
+ * Create a direcotry is platform depended.
+ */
+bool AssetsManager::createDirectory(const char *path)
+{
+#if (CC_TARGET_PLATFORM != CC_PLATFORM_WIN32)
+    mode_t processMask = umask(0);
+    int ret = mkdir(path, S_IRWXU | S_IRWXG | S_IRWXO);
+    umask(processMask);
+    if (ret != 0 && (errno != EEXIST))
+    {
+        return false;
+    }
+    
+    return true;
+#else
+    BOOL ret = CreateDirectoryA(path, NULL);
+	if (!ret && ERROR_ALREADY_EXISTS != GetLastError())
+	{
+		return false;
+	}
+    return true;
+#endif
+}
+
+void AssetsManager::setSearchPath()
+{
+    /*
+    没有必要设定 资源路径 如果不用 图片资源
+    vector<string> searchPaths = CCFileUtils::sharedFileUtils()->getSearchPaths();
+    vector<string>::iterator iter = searchPaths.begin();
+    searchPaths.insert(iter, _storagePath);
+    CCFileUtils::sharedFileUtils()->setSearchPaths(searchPaths);
+    */
+}
+
+static size_t downLoadPackage(void *ptr, size_t size, size_t nmemb, void *userdata)
+{
+    FILE *fp = (FILE*)userdata;
+    size_t written = fwrite(ptr, size, nmemb, fp);
+    return written;
+}
+
+static int progressFunc(void *ptr, double totalToDownload, double nowDownloaded, double totalToUpLoad, double nowUpLoaded)
+{
+    CCLOG("downloading... %d%%", (int)(nowDownloaded/totalToDownload*100));
+    
+    return 0;
+}
+
+bool AssetsManager::downLoad()
+{
+    // Create a file to save package.
+    string outFileName = _storagePath + TEMP_PACKAGE_FILE_NAME;
+    FILE *fp = fopen(outFileName.c_str(), "wb");
+    if (! fp)
+    {
+        CCLOG("can not create file %s", outFileName.c_str());
+        return false;
+    }
+    
+    // Download pacakge
+    CURLcode res;
+    curl_easy_setopt(_curl, CURLOPT_URL, _packageUrl.c_str());
+    curl_easy_setopt(_curl, CURLOPT_WRITEFUNCTION, downLoadPackage);
+    curl_easy_setopt(_curl, CURLOPT_WRITEDATA, fp);
+    curl_easy_setopt(_curl, CURLOPT_NOPROGRESS, false);
+    curl_easy_setopt(_curl, CURLOPT_PROGRESSFUNCTION, progressFunc);
+    res = curl_easy_perform(_curl);
+    curl_easy_cleanup(_curl);
+    if (res != 0)
+    {
+        CCLOG("error when download package");
+        fclose(fp);
+        return false;
+    }
+    
+    CCLOG("succeed downloading package %s", _packageUrl.c_str());
+    
+    fclose(fp);
+    return true;
+}
+
+const char* AssetsManager::getPackageUrl() const
+{
+    return _packageUrl.c_str();
+}
+
+void AssetsManager::setPackageUrl(const char *packageUrl)
+{
+    _packageUrl = packageUrl;
+}
+
+const char* AssetsManager::getStoragePath() const
+{
+    return _storagePath.c_str();
+}
+
+void AssetsManager::setStoragePath(const char *storagePath)
+{
+    _storagePath = storagePath;
+    checkStoragePath();
+}
+
+const char* AssetsManager::getVersionFileUrl() const
+{
+    return _versionFileUrl.c_str();
+}
+
+void AssetsManager::setVersionFileUrl(const char *versionFileUrl)
+{
+    _versionFileUrl = versionFileUrl;
+}
+
+string AssetsManager::getVersion()
+{
+    return CCUserDefault::sharedUserDefault()->getStringForKey(KEY_OF_VERSION);
+}
+
+void AssetsManager::deleteVersion()
+{
+    CCUserDefault::sharedUserDefault()->setStringForKey(KEY_OF_VERSION, "");
+}
+
+//NS_CC_EXT_END;
diff --git a/nozomi/Classes/AssetsManager/AssetsManager.h b/nozomi/Classes/AssetsManager/AssetsManager.h
new file mode 100644
index 0000000..8ecb7db
--- /dev/null
+++ b/nozomi/Classes/AssetsManager/AssetsManager.h
@@ -0,0 +1,138 @@
+/****************************************************************************
+ Copyright (c) 2013 cocos2d-x.org
+ 
+ http://www.cocos2d-x.org
+ 
+ Permission is hereby granted, free of charge, to any person obtaining a copy
+ of this software and associated documentation files (the "Software"), to deal
+ in the Software without restriction, including without limitation the rights
+ to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ copies of the Software, and to permit persons to whom the Software is
+ furnished to do so, subject to the following conditions:
+ 
+ The above copyright notice and this permission notice shall be included in
+ all copies or substantial portions of the Software.
+ 
+ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ THE SOFTWARE.
+ ****************************************************************************/
+
+#ifndef __AssetsManager__
+#define __AssetsManager__
+
+#include <string>
+#include <curl/curl.h>
+#include "support/zip_support/unzip.h"
+
+#include "cocos2d.h"
+#include "ExtensionMacros.h"
+
+//NS_CC_EXT_BEGIN
+
+/* 
+ *  This class is used to auto update resources, such as pictures or scripts.
+ *  The updated package should be a zip file. And there should be a file named
+ *  version in the server, which contains version code.
+ */
+class AssetsManager
+{
+public:
+    enum ErrorCode
+    {
+        ServerNotAvailable,    /** server address error or timeout */
+        TimeOut,
+    };
+    
+    //! Default constructor. You should set server address later.
+    AssetsManager();
+    
+    /* @brief Creates a AssetsManager with new package url and version code url.
+     *        AssetsManager will use the value returned by CCFileUtils::getWritablePath() as storage path.
+     *
+     * @param packageUrl URL of new package, the package should be a zip file.
+     * @param versionFileUrl URL of version file. It should contain version code of new package.
+     */
+    AssetsManager(const char* packageUrl, const char* versionFileUrl);
+    
+    /* @brief Creates a AssetsManager with new package url, version code url and storage path.
+     *
+     * @param packageUrl URL of new package, the package should be a zip file.
+     * @param versionFileUrl URL of version file. It should contain version code of new package.
+     * @param storagePath The path to store downloaded resources.
+     */
+    AssetsManager(const char* packageUrl, const char* versionFileUrl, const char* storagePath);
+    
+    /* @brief Check out if there is a new version resource.
+     *        You may use this method before updating, then let user determine whether
+     *        he wants to update resources.
+     */
+    virtual bool checkUpdate();
+    
+    /* @brief Download new package if there is a new version, and uncompress downloaded zip file.
+     *        Ofcourse it will set search path that stores downloaded files.
+     */
+    virtual bool update();
+    
+    /* @brief Gets url of package.
+     */
+    const char* getPackageUrl() const;
+    
+    /* @brief Sets package url.
+     */
+    void setPackageUrl(const char* packageUrl);
+    
+    /* @brief Gets version file url.
+     */
+    const char* getVersionFileUrl() const;
+    
+    /* @brief Gets version file url.
+     */
+    void setVersionFileUrl(const char* versionFileUrl);
+    
+    /* @brief Gets current version code.
+     */
+    std::string getVersion();
+    
+    /* @brief Deletes recorded version code.
+     */
+    void deleteVersion();
+    
+    /* @brief Gets storage path.
+     */
+    const char* getStoragePath() const;
+    
+    /* @brief Sets storage path.
+     *
+     * @param storagePath The path to store downloaded resources.
+     * @warm The path should be a valid path.
+     */
+    void setStoragePath(const char* storagePath);
+    
+protected:
+    bool downLoad();
+    void checkStoragePath();
+    bool uncompress();
+    bool createDirectory(const char *path);
+    void setSearchPath();
+    
+private:
+    //! The path to store downloaded resources.
+    std::string _storagePath;
+    
+    //! The version of downloaded resources.
+    std::string _version;
+    
+    std::string _packageUrl;
+    std::string _versionFileUrl;
+    
+    CURL *_curl;
+};
+
+//NS_CC_EXT_END;
+
+#endif /* defined(__AssetsManager__) */
diff --git a/nozomi/Resources/genZipAndMd5.py b/nozomi/Resources/genZipAndMd5.py
index 61d2f43..7fbc352 100644
--- a/nozomi/Resources/genZipAndMd5.py
+++ b/nozomi/Resources/genZipAndMd5.py
@@ -8,6 +8,7 @@ def tranverse(cur):
     for i in files:
         name = os.path.join(cur, i)
         if os.path.isdir(name):
+            ret.append(name)#compress file directory
             n = tranverse(name)
             ret += n
         elif name[-4:] == '.lua':
-- 
1.8.1.msysgit.1

