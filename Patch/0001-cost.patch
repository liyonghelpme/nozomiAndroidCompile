From c138f686ca395e47419a1f2a8108d8872173dd60 Mon Sep 17 00:00:00 2001
From: liyonghelpme <liyonghelpme@gmail.com>
Date: Mon, 6 May 2013 17:33:28 +0800
Subject: [PATCH 1/3] =?UTF-8?q?=E6=88=98=E6=96=97=E9=A1=B5=E9=9D=A2=E5=A3?=
 =?UTF-8?q?=AB=E5=85=B5=E9=80=89=E6=8B=A9=E8=B7=AF=E5=BE=84=20=E5=A6=82=E6?=
 =?UTF-8?q?=9E=9C=E7=9B=B8=E5=90=8C=E7=BD=91=E6=A0=BC=E5=B7=B2=E7=BB=8F=E5?=
 =?UTF-8?q?=AD=98=E5=9C=A8=E8=B7=AF=E5=BE=84=E5=88=99=E5=A2=9E=E5=8A=A0cos?=
 =?UTF-8?q?t=20=E5=BD=93=E5=A3=AB=E5=85=B5=E8=A1=8C=E8=B5=B0=E7=BB=95=E8?=
 =?UTF-8?q?=BF=87=E8=AF=A5=E6=AE=B5=E8=B7=AF=E5=BE=84=E4=B9=8B=E5=90=8E=20?=
 =?UTF-8?q?=E6=B8=85=E7=90=86=E8=B7=AF=E5=BE=84=E7=9A=84=E6=9D=83=E9=87=8D?=
 =?UTF-8?q?=E5=80=BC?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Âú®ÁªèËê•È°µÈù¢ÁßªÂä®‰πüÂèØ‰ª•‰ΩøÁî®ËøôÁßçÊñπÊ≥ï
---
 nozomi/Resources/General/network.lua |   4 +-
 nozomi/Resources/Mould/Person.lua    |  87 +++-
 nozomi/Resources/Mould/Soldier.lua   |  23 +
 nozomi/Resources/Util/SimpleJson.lua | 855 +++++++++++++++++++++++++++++++++++
 nozomi/Resources/Util/Util.lua       |  10 +-
 nozomi/Resources/Util/World.lua      |  18 +
 6 files changed, 986 insertions(+), 11 deletions(-)
 create mode 100644 nozomi/Resources/Util/SimpleJson.lua

diff --git a/nozomi/Resources/General/network.lua b/nozomi/Resources/General/network.lua
index f4eab2c..174963f 100644
--- a/nozomi/Resources/General/network.lua
+++ b/nozomi/Resources/General/network.lua
@@ -1,4 +1,4 @@
-network = {baseUrl="http://192.168.3.101:5000/"}
+network = {baseUrl="http://192.168.3.100:5000/"}
 
 -- ÈªòËÆ§ÂèÇÊï∞Âè™ÊîØÊåÅÂ≠óÁ¨¶‰∏≤ÂíåÊï∞Â≠ó
 network.httpRequest = function (url, callback, setting, delegate)
@@ -64,4 +64,4 @@ network.httpRequest = function (url, callback, setting, delegate)
 	end
 	request:start()
 	return request
-end
\ No newline at end of file
+end
diff --git a/nozomi/Resources/Mould/Person.lua b/nozomi/Resources/Mould/Person.lua
index 88127be..a3c60d2 100644
--- a/nozomi/Resources/Mould/Person.lua
+++ b/nozomi/Resources/Mould/Person.lua
@@ -176,27 +176,34 @@ function Person:getTruePath(path, world, mapGrid, fx, fy, tx, ty)
         else --∏√Œª÷√j∑¢…˙≈ˆ◊≤ ‘Ú«∞“ª∏ˆŒª÷√ «ø…“‘µΩ¥Ôµƒ
             i = j-1
             j = i + 2
-            table.insert(tempPath, path[i])
+            --¬∑æ∂µƒÕ¯∏Ò◊¯±Í “‘º∞‘⁄path÷–µƒ±‡∫≈
+            local info = {path[i][1], path[i][2], i}
+            table.insert(tempPath, info)
         end
     end
     table.insert(tempPath, path[#path])
-    --…Ë∂®world÷–Õ¯∏Ò Ù–‘”√”⁄µ˜ ‘
     path = tempPath
-    for i=1, #path, 1 do
-        world.cells[world:getKey(path[i][1], path[i][2])]['isReal'] = true
+    --πÿ±’µ˜ ‘π¶ƒ‹≤ªµ˜”√∏√∫Ø ˝
+    if world.debug then
+        --…Ë∂®world÷–Õ¯∏Ò Ù–‘”√”⁄µ˜ ‘
+        for i=1, #path, 1 do
+            world.cells[world:getKey(path[i][1], path[i][2])]['isReal'] = true
+        end
     end
 	    
 	local truePath = {}
+    --µ±∑µªÿµƒ¬∑æ∂≥§∂» = 0 –Ë“™clearPathCount ÷–ºÏ≤‚¬∑æ∂
 	if #path==0 then
-		return {{tx, ty}}
+		return {{tx, ty, 1}}
 	end
 	local curGrid = path[1]
 	for i=2, #path-1 do
 		local grid = path[i]
 		local position = mapGrid:convertToPosition(grid[1]/2, grid[2]/2)
-		table.insert(truePath, {position[1], position[2]+mapGrid.sizeY/4})
+		table.insert(truePath, {position[1], position[2]+mapGrid.sizeY/4, position[3]})
 	end
-	table.insert(truePath, {tx, ty})
+    --last path position
+	table.insert(truePath, {tx, ty, #path})
 	return truePath
 end
 		
@@ -224,10 +231,65 @@ function Person:setMoveTarget(tx, ty)
 	end
 end
 
+-- ø±¯ searchAttack —∞’“π•ª˜ƒø±Í …Ë∂®Õ¯∏ÒgridPath¬∑æ∂ ∫Õ ’Ê µ¬∑æ∂truePath
+--setPathCount
+--√ø¥Œ“∆∂Ø¡Ω∏ˆœ‡¡⁄Õ¯∏Ò «Â¿ÌÕ¯∏Ò÷Æº‰µƒÀ˘”–gridPath µƒpathCount º∆ ˝
+--clearPathCount
+--µ±“∆∂ØµΩƒøµƒµÿ
+--finishPath
+--µ±÷–ÕæÕª»ª∏ƒ±‰∑ΩœÚ
+--clearAllPath «Â¿ÌÀ˘”–µƒ¬∑æ∂
+function Person:setFromToGrid(f, t)
+    if f ~= nil and t ~= nil then
+        print("setFromToGrid"..f[3].." "..t[3])
+        self.curGrid = f
+        self.nextGrid = t
+    end
+end
+
+function Person:clearPathCount(from, to)
+    local w = self.scene.mapWorld
+    if self.gridPath ~= nil then
+        local start = from[3]
+        local finish = to[3]
+        print("clearPathCount "..start.." "..finish)
+        for i = start, finish, 1 do
+            if i <= #self.gridPath then
+                w:minusPathCount(self.gridPath[i][1], self.gridPath[i][2])
+            end
+        end
+    end
+end
+
+function Person:setPathCount() 
+    print("setPathCount")
+    local w = self.scene.mapWorld
+    for k, v in ipairs(self.gridPath) do
+        w:addPathCount(v[1], v[2]) 
+    end
+end
+function Person:clearAllPath()
+    print("clearAllPath")
+    if self.gridPath ~= nil then
+        local start = 1
+        local finish = #self.gridPath
+        for i = start, finish, 1 do
+            w:minusPathCount(self.gridPath[i][1], self.gridPath[i][2])
+        end
+        self:finishPath()
+    end
+end
+function Person:finishPath()
+    print("finishPath")
+    self.gridPath = nil
+    self.truePath = nil
+end
+
 function Person:update(diff)
 	local stateInfo = self.stateInfo
 	if stateInfo.state == "dead" then
 	end
+    -- ø±¯“∆∂Ø ∆’Õ®æ≠”™“≥√Ê»ÀŒÔ“∆∂Ø
 	if self.state == PersonState.STATE_MOVING then
 		local moveEnd = true
 		if stateInfo.toPoint then
@@ -255,11 +317,20 @@ function Person:update(diff)
 				if delta<1 then moveEnd = false end
 			end
 		end
+        --fromPoint toPoint 
+        --clearFromPoint to toPoint pathCount--
 		if moveEnd then
 			if stateInfo.movePath and #(stateInfo.movePath)>0 then
+                --«Â¿Ìµ±«∞ø™ ºµΩΩ· ¯Œ™÷πµƒÕ¯∏Ò◊¥Ã¨
+                self:clearPathCount(self.curGrid, self.nextGrid)
 				local point = table.remove(stateInfo.movePath, 1)
+                print("point is ")
+                print(point)
+                self:setFromToGrid(self.nextGrid, point)
 				self:moveDirect(point[1], point[2])
-			else
+			else --◊Ó∫Û“ª∏ˆ“∆∂ØÕ¯∏Ò
+                self:clearPathCount(self.curGrid, self.nextGrid)
+                self:finishPath()
 				self.state = PersonState.STATE_FREE
 				self.backStateInfo = self.stateInfo
 				self.backTime = self.stateTime
diff --git a/nozomi/Resources/Mould/Soldier.lua b/nozomi/Resources/Mould/Soldier.lua
index 69b630a..ab84734 100644
--- a/nozomi/Resources/Mould/Soldier.lua
+++ b/nozomi/Resources/Mould/Soldier.lua
@@ -1,4 +1,5 @@
 require "Mould.Person"
+local simpJson = require "Util.SimpleJson"
 
 
 SoldierHelper = {}
@@ -57,6 +58,14 @@ function Soldier:ctor(sid, setting)
     --…Ë∂®“∆∂Øƒø±Í÷Æ∫Û µ»¥˝“∆∂Ø ±º‰ ÷Æ∫Û‘Ÿ¥ŒºÏ≤‚æ‡¿Î
     self.moveTime = 0
     self.moveYet = false
+    -- ø±¯µƒÕ¯∏Ò¬∑æ∂
+    self.gridPath = nil
+    -- ø±¯µƒ µº ¬∑æ∂ ∂‘pathµƒindex
+    self.truePath = nil
+    -- ø±¯µ±«∞Œª÷√µƒÕ¯∏Ò±‡∫≈
+    -- ø±¯œ¬“ª∏ˆŒª÷√µƒÕ¯∏Ò±‡∫≈
+    self.curGrid = nil
+    self.nextGrid = nil
 end
 	
 function Soldier:getInitPos()
@@ -224,6 +233,8 @@ end
 function Soldier:executeAttack()
 	self.attackTarget:damage(self.stateInfo.attackValue)
 end
+--…Ë∂® ¿ΩÁ¬∑æ∂”µº∑≥Ã∂»
+
 function Soldier:searchAttack()
     local target
     local w = self.scene.mapWorld
@@ -240,10 +251,20 @@ function Soldier:searchAttack()
         --print("test1")
 
         local path, target, lastPoint = w:searchAttack(self.info.range*2, grid.gridFloatX, grid.gridFloatY)
+
         if lastPoint then
             local position = self.scene.mapGrid:convertToPosition(lastPoint[1]/2, lastPoint[2]/2)
             local tx, ty = position[1] , position[2]
             truePath = self:getTruePath(path, w, self.scene.mapGrid, fx, fy, tx, ty)
+            self:clearAllPath()
+            self.gridPath = path
+            self.truePath = truePath
+            self.setFromToGrid(self.truePath[1], self.truePath[1])
+            self:setPathCount()
+
+            print("self Data")
+            print(simpJson:encode(self.gridPath))
+            print(simpJson:encode(self.truePath))
         end	
         --print("test2")
             
@@ -255,6 +276,8 @@ function Soldier:searchAttack()
                 if self.state~=PersonState.STATE_MOVING then
                     self.stateTime = 0
                 end
+                --…Ë∂®µ±«∞Ω◊∂ŒµƒÕ¯∏Òø™ º Ω· ¯±‡∫≈ 
+                self:setFromToGrid(firstPoint, firstPoint)
                 self:moveDirect(firstPoint[1], firstPoint[2], true)
             else
                 self:setAttack()
diff --git a/nozomi/Resources/Util/SimpleJson.lua b/nozomi/Resources/Util/SimpleJson.lua
new file mode 100644
index 0000000..4be1d95
--- /dev/null
+++ b/nozomi/Resources/Util/SimpleJson.lua
@@ -0,0 +1,855 @@
+-- -*- coding: utf-8 -*-
+--
+-- Copyright 2010-2012 Jeffrey Friedl
+-- http://regex.info/blog/
+--
+local VERSION = 20111207.5  -- version history at end of file
+local OBJDEF = { VERSION = VERSION }
+
+--
+-- Simple JSON encoding and decoding in pure Lua.
+-- http://www.json.org/
+--
+--
+--   JSON = (loadfile "JSON.lua")() -- one-time load of the routines
+--
+--   local lua_value = JSON:decode(raw_json_text)
+--
+--   local raw_json_text    = JSON:encode(lua_table_or_value)
+--   local pretty_json_text = JSON:encode_pretty(lua_table_or_value) -- "pretty printed" version for human readability
+--
+--
+-- DECODING
+--
+--   JSON = (loadfile "JSON.lua")() -- one-time load of the routines
+--
+--   local lua_value = JSON:decode(raw_json_text)
+--
+--   If the JSON text is for an object or an array, e.g.
+--     { "what": "books", "count": 3 }
+--   or
+--     [ "Larry", "Curly", "Moe" ]
+--
+--   the result is a Lua table, e.g.
+--     { what = "books", count = 3 }
+--   or
+--     { "Larry", "Curly", "Moe" }
+--
+--
+--   The encode and decode routines accept an optional second argument, "etc", which is not used
+--   during encoding or decoding, but upon error is passed along to error handlers. It can be of any
+--   type (including nil).
+--
+--   With most errors during decoding, this code calls
+--
+--      JSON:onDecodeError(message, text, location, etc)
+--
+--   with a message about the error, and if known, the JSON text being parsed and the byte count
+--   where the problem was discovered. You can replace the default JSON:onDecodeError() with your
+--   own function.
+--
+--   The default onDecodeError() merely augments the message with data about the text and the
+--   location if known (and if a second 'etc' argument had been provided to decode(), its value is
+--   tacked onto the message as well), and then calls JSON.assert(), which itself defaults to Lua's
+--   built-in assert(), and can also be overridden.
+--
+--   For example, in an Adobe Lightroom plugin, you might use something like
+--
+--          function JSON:onDecodeError(message, text, location, etc)
+--             LrErrors.throwUserError("Internal Error: invalid JSON data")
+--          end
+--
+--   or even just
+--
+--          function JSON.assert(message)
+--             LrErrors.throwUserError("Internal Error: " .. message)
+--          end
+--
+--   If JSON:decode() is passed a nil, this is called instead:
+--
+--      JSON:onDecodeOfNilError(message, nil, nil, etc)
+--
+--   and if JSON:decode() is passed HTML instead of JSON, this is called:
+--
+--      JSON:onDecodeOfHTMLError(message, text, nil, etc)
+--
+--   The use of the fourth 'etc' argument allows stronger coordination between decoding and error
+--   reporting, especially when you provide your own error-handling routines. Continuing with the
+--   the Adobe Lightroom plugin example:
+--
+--          function JSON:onDecodeError(message, text, location, etc)
+--             local note = "Internal Error: invalid JSON data"
+--             if type(etc) = 'table' and etc.photo then
+--                note = note .. " while processing for " .. etc.photo:getFormattedMetadata('fileName')
+--             end
+--             LrErrors.throwUserError(note)
+--          end
+--
+--            :
+--            :
+--
+--          for i, photo in ipairs(photosToProcess) do
+--               :             
+--               :             
+--               local data = JSON:decode(someJsonText, { photo = photo })
+--               :             
+--               :             
+--          end
+--
+--
+--
+--
+
+-- DECODING AND STRICT TYPES
+--
+--   Because both JSON objects and JSON arrays are converted to Lua tables, it's not normally
+--   possible to tell which a Lua table came from, or guarantee decode-encode round-trip
+--   equivalency.
+--
+--   However, if you enable strictTypes, e.g.
+--
+--      JSON = (loadfile "JSON.lua")() --load the routines
+--      JSON.strictTypes = true
+--
+--   then the Lua table resulting from the decoding of a JSON object or JSON array is marked via Lua
+--   metatable, so that when re-encoded with JSON:encode() it ends up as the appropriate JSON type.
+--
+--   (This is not the default because other routines may not work well with tables that have a
+--   metatable set, for example, Lightroom API calls.)
+--
+--
+-- ENCODING
+--
+--   JSON = (loadfile "JSON.lua")() -- one-time load of the routines
+--
+--   local raw_json_text    = JSON:encode(lua_table_or_value)
+--   local pretty_json_text = JSON:encode_pretty(lua_table_or_value) -- "pretty printed" version for human readability
+
+--   On error during encoding, this code calls:
+--
+--    JSON:onEncodeError(message, etc)
+--
+--   which you can override in your local JSON object.
+--
+--
+-- SUMMARY OF METHODS YOU CAN OVERRIDE IN YOUR LOCAL LUA JSON OBJECT
+--
+--    assert
+--    onDecodeError
+--    onDecodeOfNilError
+--    onDecodeOfHTMLError
+--    onEncodeError
+--
+--  If you want to create a separate Lua JSON object with its own error handlers,
+--  you can reload JSON.lua or use the :new() method.
+--
+---------------------------------------------------------------------------
+
+
+local author = "-[ JSON.lua package by Jeffrey Friedl (http://regex.info/blog/lua/json), version " .. tostring(VERSION) .. " ]-"
+local isArray  = { __tostring = function() return "JSON array"  end }    isArray.__index  = isArray
+local isObject = { __tostring = function() return "JSON object" end }    isObject.__index = isObject
+
+
+function OBJDEF:newArray(tbl)
+   return setmetatable(tbl or {}, isArray)
+end
+
+function OBJDEF:newObject(tbl)
+   return setmetatable(tbl or {}, isObject)
+end
+
+local function unicode_codepoint_as_utf8(codepoint)
+   --
+   -- codepoint is a number
+   --
+   if codepoint <= 127 then
+      return string.char(codepoint)
+
+   elseif codepoint <= 2047 then
+      --
+      -- 110yyyxx 10xxxxxx         <-- useful notation from http://en.wikipedia.org/wiki/Utf8
+      --
+      local highpart = math.floor(codepoint / 0x40)
+      local lowpart  = codepoint - (0x40 * highpart)
+      return string.char(0xC0 + highpart,
+                         0x80 + lowpart)
+
+   elseif codepoint <= 65535 then
+      --
+      -- 1110yyyy 10yyyyxx 10xxxxxx
+      --
+      local highpart  = math.floor(codepoint / 0x1000)
+      local remainder = codepoint - 0x1000 * highpart
+      local midpart   = math.floor(remainder / 0x40)
+      local lowpart   = remainder - 0x40 * midpart
+
+      highpart = 0xE0 + highpart
+      midpart  = 0x80 + midpart
+      lowpart  = 0x80 + lowpart
+
+      --
+      -- Check for an invalid character (thanks Andy R. at Adobe).
+      -- See table 3.7, page 93, in http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#G28070
+      --
+      if ( highpart == 0xE0 and midpart < 0xA0 ) or
+         ( highpart == 0xED and midpart > 0x9F ) or
+         ( highpart == 0xF0 and midpart < 0x90 ) or
+         ( highpart == 0xF4 and midpart > 0x8F )
+      then
+         return "?"
+      else
+         return string.char(highpart,
+                            midpart,
+                            lowpart)
+      end
+
+   else
+      --
+      -- 11110zzz 10zzyyyy 10yyyyxx 10xxxxxx
+      --
+      local highpart  = math.floor(codepoint / 0x40000)
+      local remainder = codepoint - 0x40000 * highpart
+      local midA      = math.floor(remainder / 0x1000)
+      remainder       = remainder - 0x1000 * midA
+      local midB      = math.floor(remainder / 0x40)
+      local lowpart   = remainder - 0x40 * midB
+
+      return string.char(0xF0 + highpart,
+                         0x80 + midA,
+                         0x80 + midB,
+                         0x80 + lowpart)
+   end
+end
+
+function OBJDEF:onDecodeError(message, text, location, etc)
+   if text then
+      if location then
+         message = string.format("%s at char %d of: %s", message, location, text)
+      else
+         message = string.format("%s: %s", message, text)
+      end
+   end
+   if etc ~= nil then
+      message = message .. " (" .. OBJDEF:encode(etc) .. ")"
+   end
+
+   if self.assert then
+      self.assert(false, message)
+   else
+      assert(false, message)
+   end
+end
+
+OBJDEF.onDecodeOfNilError  = OBJDEF.onDecodeError
+OBJDEF.onDecodeOfHTMLError = OBJDEF.onDecodeError
+
+function OBJDEF:onEncodeError(message, etc)
+   if etc ~= nil then
+      message = message .. " (" .. OBJDEF:encode(etc) .. ")"
+   end
+
+   if self.assert then
+      self.assert(false, message)
+   else
+      assert(false, message)
+   end
+end
+
+local function grok_number(self, text, start, etc)
+   --
+   -- Grab the integer part
+   --
+   local integer_part = text:match('^-?[1-9]%d*', start)
+                     or text:match("^-?0",        start)
+
+   if not integer_part then
+      self:onDecodeError("expected number", text, start, etc)
+   end
+
+   local i = start + integer_part:len()
+
+   --
+   -- Grab an optional decimal part
+   --
+   local decimal_part = text:match('^%.%d+', i) or ""
+
+   i = i + decimal_part:len()
+
+   --
+   -- Grab an optional exponential part
+   --
+   local exponent_part = text:match('^[eE][-+]?%d+', i) or ""
+
+   i = i + exponent_part:len()
+
+   local full_number_text = integer_part .. decimal_part .. exponent_part
+   local as_number = tonumber(full_number_text)
+
+   if not as_number then
+      self:onDecodeError("bad number", text, start, etc)
+   end
+
+   return as_number, i
+end
+
+
+local function grok_string(self, text, start, etc)
+
+   if text:sub(start,start) ~= '"' then
+      self:onDecodeError("expected string's opening quote", text, start, etc)
+   end
+
+   local i = start + 1 -- +1 to bypass the initial quote
+   local text_len = text:len()
+   local VALUE = ""
+   while i <= text_len do
+      local c = text:sub(i,i)
+      if c == '"' then
+         return VALUE, i + 1
+      end
+      if c ~= '\\' then
+         VALUE = VALUE .. c
+         i = i + 1
+      elseif text:match('^\\b', i) then
+         VALUE = VALUE .. "\b"
+         i = i + 2
+      elseif text:match('^\\f', i) then
+         VALUE = VALUE .. "\f"
+         i = i + 2
+      elseif text:match('^\\n', i) then
+         VALUE = VALUE .. "\n"
+         i = i + 2
+      elseif text:match('^\\r', i) then
+         VALUE = VALUE .. "\r"
+         i = i + 2
+      elseif text:match('^\\t', i) then
+         VALUE = VALUE .. "\t"
+         i = i + 2
+      else
+         local hex = text:match('^\\u([0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF])', i)
+         if hex then
+            i = i + 6 -- bypass what we just read
+
+            -- We have a Unicode codepoint. It could be standalone, or if in the proper range and
+            -- followed by another in a specific range, it'll be a two-code surrogate pair.
+            local codepoint = tonumber(hex, 16)
+            if codepoint >= 0xD800 and codepoint <= 0xDBFF then
+               -- it's a hi surrogate... see whether we have a following low
+               local lo_surrogate = text:match('^\\u([dD][cdefCDEF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF])', i)
+               if lo_surrogate then
+                  i = i + 6 -- bypass the low surrogate we just read
+                  codepoint = 0x2400 + (codepoint - 0xD800) * 0x400 + tonumber(lo_surrogate, 16)
+               else
+                  -- not a proper low, so we'll just leave the first codepoint as is and spit it out.
+               end
+            end
+            VALUE = VALUE .. unicode_codepoint_as_utf8(codepoint)
+
+         else
+
+            -- just pass through what's escaped
+            VALUE = VALUE .. text:match('^\\(.)', i)
+            i = i + 2
+         end
+      end
+   end
+
+   self:onDecodeError("unclosed string", text, start, etc)
+end
+
+local function skip_whitespace(text, start)
+
+   local match_start, match_end = text:find("^[ \n\r\t]+", start) -- [http://www.ietf.org/rfc/rfc4627.txt] Section 2
+   if match_end then
+      return match_end + 1
+   else
+      return start
+   end
+end
+
+local grok_one -- assigned later
+
+local function grok_object(self, text, start, etc)
+   if not text:sub(start,start) == '{' then
+      self:onDecodeError("expected '{'", text, start, etc)
+   end
+
+   local i = skip_whitespace(text, start + 1) -- +1 to skip the '{'
+
+   local VALUE = self.strictTypes and self:newObject { } or { }
+
+   if text:sub(i,i) == '}' then
+      return VALUE, i + 1
+   end
+   local text_len = text:len()
+   while i <= text_len do
+      local key, new_i = grok_string(self, text, i, etc)
+
+      i = skip_whitespace(text, new_i)
+
+      if text:sub(i, i) ~= ':' then
+         self:onDecodeError("expected colon", text, i, etc)
+      end
+
+      i = skip_whitespace(text, i + 1)
+
+      local val, new_i = grok_one(self, text, i)
+
+      VALUE[key] = val
+
+      --
+      -- Expect now either '}' to end things, or a ',' to allow us to continue.
+      --
+      i = skip_whitespace(text, new_i)
+
+      local c = text:sub(i,i)
+
+      if c == '}' then
+         return VALUE, i + 1
+      end
+
+      if text:sub(i, i) ~= ',' then
+         self:onDecodeError("expected comma or '}'", text, i, etc)
+      end
+
+      i = skip_whitespace(text, i + 1)
+   end
+
+   self:onDecodeError("unclosed '{'", text, start, etc)
+end
+
+local function grok_array(self, text, start, etc)
+   if not text:sub(start,start) == '[' then
+      self:onDecodeError("expected '['", text, start, etc)
+   end
+
+   local i = skip_whitespace(text, start + 1) -- +1 to skip the '['
+   local VALUE = self.strictTypes and self:newArray { } or { }
+   if text:sub(i,i) == ']' then
+      return VALUE, i + 1
+   end
+
+   local text_len = text:len()
+   while i <= text_len do
+      local val, new_i = grok_one(self, text, i)
+
+      table.insert(VALUE, val)
+
+      i = skip_whitespace(text, new_i)
+
+      --
+      -- Expect now either ']' to end things, or a ',' to allow us to continue.
+      --
+      local c = text:sub(i,i)
+      if c == ']' then
+         return VALUE, i + 1
+      end
+      if text:sub(i, i) ~= ',' then
+         self:onDecodeError("expected comma or '['", text, i, etc)
+      end
+      i = skip_whitespace(text, i + 1)
+   end
+   self:onDecodeError("unclosed '['", text, start, etc)
+end
+
+
+grok_one = function(self, text, start, etc)
+   -- Skip any whitespace
+   start = skip_whitespace(text, start)
+
+   if start > text:len() then
+      self:onDecodeError("unexpected end of string", text, nil, etc)
+   end
+
+   if text:find('^"', start) then
+      return grok_string(self, text, start, etc)
+
+   elseif text:find('^[-0123456789 ]', start) then
+      return grok_number(self, text, start, etc)
+
+   elseif text:find('^%{', start) then
+      return grok_object(self, text, start, etc)
+
+   elseif text:find('^%[', start) then
+      return grok_array(self, text, start, etc)
+
+   elseif text:find('^true', start) then
+      return true, start + 4
+
+   elseif text:find('^false', start) then
+      return false, start + 5
+
+   elseif text:find('^null', start) then
+      return nil, start + 4
+
+   else
+      self:onDecodeError("can't parse JSON", text, start, etc)
+   end
+end
+
+function OBJDEF:decode(text, etc)
+   if type(self) ~= 'table' or self.__index ~= OBJDEF then
+      OBJDEF:onDecodeError("JSON:decode must be called in method format", nil, nil, etc)
+   end
+
+   if text == nil then
+      self:onDecodeOfNilError(string.format("nil passed to JSON:decode()"), nil, nil, etc)
+   elseif type(text) ~= 'string' then
+      self:onDecodeError(string.format("expected string argument to JSON:decode(), got %s", type(text)), nil, nil, etc)
+   end
+
+   if text:match('^%s*$') then
+      return nil
+   end
+
+   if text:match('^%s*<') then
+      -- Can't be JSON... we'll assume it's HTML
+      self:onDecodeOfHTMLError(string.format("html passed to JSON:decode()"), text, nil, etc)
+   end
+
+   --
+   -- Ensure that it's not UTF-32 or UTF-16.
+   -- Those are perfectly valid encodings for JSON (as per RFC 4627 section 3),
+   -- but this package can't handle them.
+   --
+   if text:sub(1,1):byte() == 0 or (text:len() >= 2 and text:sub(2,2):byte() == 0) then
+      self:onDecodeError("JSON package groks only UTF-8, sorry", text, nil, etc)
+   end
+
+   local success, value = pcall(grok_one, self, text, 1, etc)
+   if success then
+      return value
+   else
+      -- should never get here... JSON parse errors should have been caught earlier
+      assert(false, value)
+      return nil
+   end
+end
+
+local function backslash_replacement_function(c)
+   if c == "\n" then
+      return "\\n"
+   elseif c == "\r" then
+      return "\\r"
+   elseif c == "\t" then
+      return "\\t"
+   elseif c == "\b" then
+      return "\\b"
+   elseif c == "\f" then
+      return "\\f"
+   elseif c == '"' then
+      return '\\"'
+   elseif c == '\\' then
+      return '\\\\'
+   else
+      return string.format("\\u%04x", c:byte())
+   end
+end
+
+local chars_to_be_escaped_in_JSON_string
+   = '['
+   ..    '"'    -- class sub-pattern to match a double quote
+   ..    '%\\'  -- class sub-pattern to match a backslash
+   ..    '%z'   -- class sub-pattern to match a null
+   ..    '\001' .. '-' .. '\031' -- class sub-pattern to match control characters
+   .. ']'
+
+local function json_string_literal(value)
+   local newval = value:gsub(chars_to_be_escaped_in_JSON_string, backslash_replacement_function)
+   return '"' .. newval .. '"'
+end
+
+local function object_or_array(self, T, etc)
+   --
+   -- We need to inspect all the keys... if there are any strings, we'll convert to a JSON
+   -- object. If there are only numbers, it's a JSON array.
+   --
+   -- If we'll be converting to a JSON object, we'll want to sort the keys so that the
+   -- end result is deterministic.
+   --
+   local string_keys = { }
+   local seen_number_key = false
+   local maximum_number_key
+
+   for key in pairs(T) do
+      if type(key) == 'number' then
+         seen_number_key = true
+         if not maximum_number_key or maximum_number_key < key then
+            maximum_number_key = key
+         end
+      elseif type(key) == 'string' then
+         table.insert(string_keys, key)
+      else
+         self:onEncodeError("can't encode table with a key of type " .. type(key), etc)
+      end
+   end
+
+   if seen_number_key and #string_keys > 0 then
+      --
+      -- Mixed key types... don't know what to do, so bail
+      --
+      self:onEncodeError("a table with both numeric and string keys could be an object or array; aborting", etc)
+
+   elseif #string_keys == 0  then
+      --
+      -- An array
+      --
+      if seen_number_key then
+         return nil, maximum_number_key -- an array
+      else
+         --
+         -- An empty table...
+         --
+         if tostring(T) == "JSON array" then
+            return nil
+         elseif tostring(T) == "JSON object" then
+            return { }
+         else
+            -- have to guess, so we'll pick array, since empty arrays are likely more common than empty objects
+            return nil
+         end
+      end
+   else
+      --
+      -- An object, so return a list of keys
+      --
+      table.sort(string_keys)
+      return string_keys
+   end
+end
+
+--
+-- Encode
+--
+local encode_value -- must predeclare because it calls itself
+function encode_value(self, value, parents, etc)
+
+
+   if value == nil then
+      return 'null'
+   end
+
+   if type(value) == 'string' then
+      return json_string_literal(value)
+   elseif type(value) == 'number' then
+      if value ~= value then
+         --
+         -- NaN (Not a Number).
+         -- JSON has no NaN, so we have to fudge the best we can. This should really be a package option.
+         --
+         return "null"
+      elseif value >= math.huge then
+         --
+         -- Positive infinity. JSON has no INF, so we have to fudge the best we can. This should
+         -- really be a package option. Note: at least with some implementations, positive infinity
+         -- is both ">= math.huge" and "<= -math.huge", which makes no sense but that's how it is.
+         -- Negative infinity is properly "<= -math.huge". So, we must be sure to check the ">="
+         -- case first.
+         --
+         return "1e+9999"
+      elseif value <= -math.huge then
+         --
+         -- Negative infinity.
+         -- JSON has no INF, so we have to fudge the best we can. This should really be a package option.
+         --
+         return "-1e+9999"
+      else
+         return tostring(value)
+      end
+   elseif type(value) == 'boolean' then
+      return tostring(value)
+
+   elseif type(value) ~= 'table' then
+      self:onEncodeError("can't convert " .. type(value) .. " to JSON", etc)
+
+   else
+      --
+      -- A table to be converted to either a JSON object or array.
+      --
+      local T = value
+
+      if parents[T] then
+         self:onEncodeError("table " .. tostring(T) .. " is a child of itself", etc)
+      else
+         parents[T] = true
+      end
+
+      local result_value
+
+      local object_keys, maximum_number_key = object_or_array(self, T, etc)
+      if maximum_number_key then
+         --
+         -- An array...
+         --
+         local ITEMS = { }
+         for i = 1, maximum_number_key do
+            table.insert(ITEMS, encode_value(self, T[i], parents, etc))
+         end
+
+         result_value = "[" .. table.concat(ITEMS, ",") .. "]"
+      elseif object_keys then
+         --
+         -- An object
+         --
+
+         --
+         -- We'll always sort the keys, so that comparisons can be made on
+         -- the results, etc. The actual order is not particularly
+         -- important (e.g. it doesn't matter what character set we sort
+         -- as); it's only important that it be deterministic... the same
+         -- every time.
+         --
+         local PARTS = { }
+         for _, key in ipairs(object_keys) do
+            local encoded_key = encode_value(self, tostring(key), parents, etc)
+            local encoded_val = encode_value(self, T[key],        parents, etc)
+            table.insert(PARTS, string.format("%s:%s", encoded_key, encoded_val))
+         end
+         result_value = "{" .. table.concat(PARTS, ",") .. "}"
+      else
+         --
+         -- An empty array/object... we'll treat it as an array, though it should really be an option
+         --
+         result_value = "[]"
+      end
+
+      parents[T] = false
+      return result_value
+   end
+end
+
+local encode_pretty_value -- must predeclare because it calls itself
+function encode_pretty_value(self, value, parents, indent, etc)
+
+   if type(value) == 'string' then
+      return json_string_literal(value)
+
+   elseif type(value) == 'number' then
+      return tostring(value)
+
+   elseif type(value) == 'boolean' then
+      return tostring(value)
+
+   elseif type(value) == 'nil' then
+      return 'null'
+
+   elseif type(value) ~= 'table' then
+      self:onEncodeError("can't convert " .. type(value) .. " to JSON", etc)
+
+   else
+      --
+      -- A table to be converted to either a JSON object or array.
+      --
+      local T = value
+
+      if parents[T] then
+         self:onEncodeError("table " .. tostring(T) .. " is a child of itself", etc)
+      end
+      parents[T] = true
+
+      local result_value
+
+      local object_keys = object_or_array(self, T, etc)
+      if not object_keys then
+         --
+         -- An array...
+         --
+         local ITEMS = { }
+         for i = 1, #T do
+            table.insert(ITEMS, encode_pretty_value(self, T[i], parents, indent, etc))
+         end
+
+         result_value = "[ " .. table.concat(ITEMS, ", ") .. " ]"
+
+      else
+
+         --
+         -- An object -- can keys be numbers?
+         --
+
+         local KEYS = { }
+         local max_key_length = 0
+         for _, key in ipairs(object_keys) do
+            local encoded = encode_pretty_value(self, tostring(key), parents, "", etc)
+            max_key_length = math.max(max_key_length, #encoded)
+            table.insert(KEYS, encoded)
+         end
+         local key_indent = indent .. "    "
+         local subtable_indent = indent .. string.rep(" ", max_key_length + 2 + 4)
+         local FORMAT = "%s%" .. tostring(max_key_length) .. "s: %s"
+
+         local COMBINED_PARTS = { }
+         for i, key in ipairs(object_keys) do
+            local encoded_val = encode_pretty_value(self, T[key], parents, subtable_indent, etc)
+            table.insert(COMBINED_PARTS, string.format(FORMAT, key_indent, KEYS[i], encoded_val))
+         end
+         result_value = "{\n" .. table.concat(COMBINED_PARTS, ",\n") .. "\n" .. indent .. "}"
+      end
+
+      parents[T] = false
+      return result_value
+   end
+end
+
+function OBJDEF:encode(value, etc)
+   if type(self) ~= 'table' or self.__index ~= OBJDEF then
+      OBJDEF:onEncodeError("JSON:encode must be called in method format", etc)
+   end
+
+   local parents = {}
+   return encode_value(self, value, parents, etc)
+end
+
+function OBJDEF:encode_pretty(value, etc)
+   local parents = {}
+   local subtable_indent = ""
+   return encode_pretty_value(self, value, parents, subtable_indent, etc)
+end
+
+function OBJDEF.__tostring()
+   return "JSON encode/decode package"
+end
+
+OBJDEF.__index = OBJDEF
+
+function OBJDEF:new(args)
+   local new = { }
+
+   if args then
+      for key, val in pairs(args) do
+         new[key] = val
+      end
+   end
+
+   return setmetatable(new, OBJDEF)
+end
+
+return OBJDEF:new()
+
+--
+-- Version history:
+--
+--   20111207.5    Added support for the 'etc' arguments, for better error reporting.
+--
+--   20110731.4    More feedback from David Kolf on how to make the tests for Nan/Infinity system independent.
+--
+--   20110730.3    Incorporated feedback from David Kolf at http://lua-users.org/wiki/JsonModules:
+--
+--                   * When encoding lua for JSON, Sparse numeric arrays are now handled by
+--                     spitting out full arrays, such that
+--                        JSON:encode({"one", "two", [10] = "ten"})
+--                     returns
+--                        ["one","two",null,null,null,null,null,null,null,"ten"]
+--
+--                     In 20100810.2 and earlier, only up to the first non-null value would have been retained.
+--
+--                   * When encoding lua for JSON, numeric value NaN gets spit out as null, and infinity as "1+e9999".
+--                     Version 20100810.2 and earlier created invalid JSON in both cases.
+--
+--                   * Unicode surrogate pairs are now detected when decoding JSON.
+--
+--   20100810.2    added some checking to ensure that an invalid Unicode character couldn't leak in to the UTF-8 encoding
+--
+--   20100731.1    initial public release
+--
diff --git a/nozomi/Resources/Util/Util.lua b/nozomi/Resources/Util/Util.lua
index 7cb71c9..f8c30e1 100644
--- a/nozomi/Resources/Util/Util.lua
+++ b/nozomi/Resources/Util/Util.lua
@@ -232,6 +232,14 @@ function recurSetColor(sprite, color)
 	end
 end
 
+function printArray(arr)
+    local res = ""
+    for k, v in ipairs(arr) do
+        res = res .. v
+    end
+    print(res)
+end
+
 require "Util.Class"
 require "Util.character"
 require "Util.json"
@@ -242,4 +250,4 @@ require "Util.RhombGrid"
 
 require "Util.Touch"
 require "Util.World"
-require "Util.Ray"
\ No newline at end of file
+require "Util.Ray"
diff --git a/nozomi/Resources/Util/World.lua b/nozomi/Resources/Util/World.lua
index 36c905d..3a245a6 100644
--- a/nozomi/Resources/Util/World.lua
+++ b/nozomi/Resources/Util/World.lua
@@ -286,6 +286,10 @@ function World:calcG(x, y)
     elseif difX > 0 and difY > 0 then
         dist = 14
     end
+    --Ë∑ØÂæÑÊã•Êå§Á®ãÂ∫¶
+    if data['pathCount'] ~= nil then
+        dist = dist + data['pathCount']*15
+    end
     --print("calG "..dist)
 
 
@@ -492,6 +496,20 @@ function World:search()
     return temp
 end
 
+function World:minusPathCount(x, y)
+    local key = self:getKey(x, y)
+    local old = self.cells[key]['pathCount'] or 0
+    if old > 0 then
+        self.cells[key]['pathCount'] = old - 1
+    else
+        print("PathError PathCount-1 < 0") 
+    end
+end
+function World:addPathCount(x, y)
+    local key = self:getKey(x, y)
+    local old = self.cells[key]['pathCount'] or 0
+    self.cells[key]['pathCount'] = old+1
+end
 function World:searchAttack(range, fx, fy)
     self.searchNum = self.searchNum + 1
     if self.searchNum >= self.maxSearchNum then
-- 
1.8.1.msysgit.1

